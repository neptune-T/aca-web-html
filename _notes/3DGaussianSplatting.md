---
title: '3D Gaussian Splatting'
date: '2025-09'
summary: 'Represents a 3D scene as an explicit set of anisotropic 3D Gaussians, each defined by parameters for position, covariance, opacity, and view-dependent color via Spherical Harmonics. Optimizes all parameters from images using stochastic gradient descent, coupled with an adaptive density control mechanism that dynamically clones, splits, and prunes the Gaussians to create a detailed and efficient scene representation.'
tags: ['Computer Graphics']
---

![](https://raw.githubusercontent.com/neptune-t/aca-web-html/main/public/img/3dgs/1.png)

# 三维场景的参数化表示


3D Gaussian Splatting (3GS) 理论框架的基础，是将一个三维场景形式化地定义为一个由 $N$ 个参数化的、各向异性的**三维高斯基元**构成的集合。在该模型中，每一个独立的基元 $i$ 并非一个具有明确边界的几何实体，而是一个由其统计矩决定的场。其核心的几何与物理属性被一组参数完整地描述。

具体而言，一个基元的几何位置由其均值向量 $\vec{\mu}_i \in \mathbb{R}^3$ 确定，该向量定义了其在世界坐标系中的中心。该基元的空间范围、形状及朝向则由一个对称正定协方差矩阵 $\Sigma_i \in \mathbb{R}^{3 \times 3}$ 所刻画。协方差矩阵的引入是至关重要的，*它使得基元能够表达任意的椭球形态，从而具备了高效建模平面、细丝等各向异性结构的能力*，这是区别于各向同性基元（如球体）的关键。在优化过程中，为了保证协方差矩阵的正定性并提供更直观的几何控制，该矩阵通常被分解并由一个代表旋转的四元数 $\vec{q}_i$ 和一个代表三轴非均匀缩放的向量 $\vec{s}_i$ 共同参数化。

除了几何属性，每个基元还承载了其光度学属性。其一为不透明度 $\alpha_i \in [0, 1]$，这是一个标量，用于描述该基元对光线的遮挡能力。其二为辐射度，为了能够表现视角依赖的复杂外观（如高光反射），它并非一个静态的RGB颜色值，而是通过一组球谐函数 (Spherical Harmonics) 的系数 $c_i$ 来建模。因此，一个完整的三维场景在3GS的框架下，被最终表示为这 $N$ 个基元的所有参数的集合，即 $\{\vec{\mu}_i, \vec{q}_i, \vec{s}_i, c_i, \alpha_i\}_{i=1}^N$。


# 高斯分布与椭球的几何联系

笔者在上面确立了协方差矩阵 $\Sigma$ 是描述高斯基元几何形态的关键参数。现在，我们将从数学上严格阐明这一关联。一个以向量 $\vec{\mu}$ 为中心的三维高斯分布，其概率密度函数正比于以下指数项：

$$
\begin{equation}
f(\vec{x}) \propto \exp\left(-\frac{1}{2}(\vec{x}-\vec{\mu})^T \Sigma^{-1} (\vec{x}-\vec{\mu})\right)
\end{equation}
$$

该函数的核心结构由其指数内的二次型 $(\vec{x}-\vec{\mu})^T \Sigma^{-1} (\vec{x}-\vec{\mu})$ 决定。

在解析几何中，一个以 $\vec{\mu}$ 为中心的三维椭球体，其表面上的所有点 $\vec{x}$ 均满足方程 $(\vec{x}-\vec{\mu})^T A (\vec{x}-\vec{\mu}) = c^2$，其中 $A$ 是一个对称正定矩阵，常数 $c$ 决定了椭球的大小。通过直接对比这两种数学形式，我们可以建立一个精确的对应关系：定义高斯分布的协方差矩阵的逆矩阵 $\Sigma^{-1}$，在数学上等价于定义了椭球形状的矩阵 $A$。因此，高斯函数值保持恒定的等值面，正是由其协方差矩阵的逆矩阵所定义的同心椭球簇。

我们可以通过一个简单的对角化情形来直观地理解为何是逆矩阵 $\Sigma^{-1}$ 而非 $\Sigma$ 本身决定了椭球的几何。

假设一个高斯分布在坐标轴方向上没有旋转，其协方差矩阵 $\Sigma$ 为一对角矩阵，对角线元素为 $(\sigma_x^2, \sigma_y^2, \sigma_z^2)$，这些值分别代表了数据点在各轴上的方差。此时，其逆矩阵 $\Sigma^{-1}$ 也是对角矩阵，对角线元素为 $(1/\sigma_x^2, 1/\sigma_y^2, 1/\sigma_z^2)$。那么，二次型就展开为：

$$
\begin{equation}
\frac{(x-\mu_x)^2}{\sigma_x^2} + \frac{(y-\mu_y)^2}{\sigma_y^2} + \frac{(z-\mu_z)^2}{\sigma_z^2}
\end{equation}
$$

若令此表达式等于常数1，我们便得到了标准椭球方程，其沿着 x, y, z 轴的半轴长度分别为 $\sigma_x, \sigma_y, \sigma_z$。这个结果清晰地表明，协方差矩阵 $\Sigma$ 的对角元素的平方根，直接对应于椭球的半轴长度。这也解释了两者间的逆关系：一个在某轴方向上较大的方差（$\sigma_x^2$ 很大），意味着高斯分布在该方向上很“胖”，这正对应于一个在该轴向上具有较大半径（$r_x = \sigma_x$）的椭球。



# 协方差矩阵的几何参数提取与重构

我们已经知道协方差矩阵 $\Sigma$ 唯一地确定了一个高斯基元的几何形态，但一个 $3 \times 3$ 矩阵的九个分量本身并不直观。为了获取该椭球体的具体朝向和主轴长度等几何参数，我们需要借助线性代数中的特征分解工具。任何一个对称矩阵 $\Sigma$ 都可以被分解为 $\Sigma = U \Lambda U^T$ 的形式。在此分解中，$U$ 是一个由 $\Sigma$ 的标准正交特征向量为列向量构成的正交矩阵，它在几何上精确地对应于一个旋转矩阵，定义了椭球体三个主轴在世界坐标系中的方向。$\Lambda$ 则是一个对角矩阵，其对角线上的元素 $\lambda_1, \lambda_2, \lambda_3$ 是 $\Sigma$ 对应的特征值。这些特征值的平方根，即 $\sqrt{\lambda_1}, \sqrt{\lambda_2}, \sqrt{\lambda_3}$，直接给出了椭球体沿着由 $U$ 定义的三个主轴方向的半轴长度。因此，通过对 $\Sigma$ 进行特征分解，我们能够完全地将其从一个抽象的数学对象，解码为一个具有明确旋转和尺寸的几何实体。

然而，在通过梯度下降法对场景进行优化时，直接存储并更新协方差矩阵 $\Sigma$ 的九个元素是不可行的。其根本原因在于，协方差矩阵必须始终保持对称正定（或至少是半正定）的数学性质，以确保其对应一个几何上有效的椭球且概率密度函数有意义。标准的梯度更新无法保证在迭代过程中维持此约束，优化过程很可能会产生一个无效的矩阵，导致数值不稳定甚至崩溃。此外，直接优化矩阵元素的梯度物理意义不明确，难以实现直观的几何控制。

为了规避这些问题，3D Gaussian Splatting 采用了一种更为稳定和优雅的参数化重构方法。它并不直接优化协方差矩阵本身，而是优化一组更符合几何直觉的独立参数：一个代表旋转的**四元数** $\vec{q} \in \mathbb{R}^4$ 和一个代表缩放的**向量** $\vec{s} \in \mathbb{R}^3$。

四元数是一种在三维图形学中广泛应用的、用于表示旋转的四维向量，它可以无奇异点地转换为一个 $3 \times 3$ 的旋转矩阵 $R$。缩放向量 $\vec{s}$ 的三个分量则直接对应于椭球在自身局部坐标系下三个主轴方向上的尺寸。通过这两个参数，一个有效的协方差矩阵可以被确定地重构出来，其构造公式为：

$$
\begin{equation}
\Sigma = R S S^T R^T
\end{equation}
$$

其中 $R$ 是由四元数 $\vec{q}$ 转换而来的旋转矩阵，$S$ 是由缩放向量 $\vec{s}$ 构成的对角矩阵。这个构造过程在数学上确保了最终生成的矩阵 $\Sigma$ 始终是对称且半正定的，从而完美地解决了直接优化所面临的约束问题。通过优化在几何上更具意义的 $\vec{q}$ 和 $\vec{s}$，整个训练过程变得更加稳定和高效。



# 球谐函数与视角依赖的外观建模

一个三维物体的外观在真实世界中并非一成不变，而是会随着观察角度的变化而改变，这种现象被称为视角依赖效果，例如金属的高光反射或天鹅绒的独特光泽。为了在渲染中重现这种真实感，为每个高斯基元赋予一个静态不变的RGB颜色是远远不够的。

因此，3D Gaussian Splatting 这里采用了一种更为强大的光度学模型，即 **球谐函数(Spherical Harmonics, SH)** 来对每个基元所发出的辐射度进行建模。球谐函数可以被理解为定义在球面上的函数的傅里叶级数，任何一个定义在球面上的复杂函数，都可以被分解为一组标准正交的球谐基函数的线性组合。

在该框架中，我们并不直接存储每个高斯基元在所有出射方向上的颜色值，而是为每个基元存储一组数量固定、维度较低的**球谐函数系数** $c_i$。这些系数是在场景优化（训练）过程中被学习和更新的参数。在渲染的时刻，对于一个给定的观察方向（由从基元中心指向相机的单位向量 $\vec{d}$ 表示），最终的颜色 $C(\vec{d})$ 便是通过将这些学习到的系数与对应的球谐基函数 $Y_{lm}(\vec{d})$ 在该方向上的取值进行线性组合来动态计算（重构）的。其数学表达式为：

$$
\begin{equation}
C(\vec{d}) = \sum_{l=0}^{L_{max}} \sum_{m=-l}^{l} \vec{c}_{lm} Y_{lm}(\vec{d})
\end{equation}
$$

在这个求和式中，$l$ 和 $m$ 分别代表球谐函数的阶和次。阶数 $l$ 越高，基函数 $Y_{lm}$ 在球面上的频率越高，能够表示的颜色变化细节也就越丰富。$L_{max}$ 是预设的最高阶数，它决定了模型能够捕捉的外观复杂度的上限，3GS 通常使用到3阶。

$\vec{c}_{lm}$ 是与每个基函数 $Y_{lm}$ 相关联的、学习到的系数向量，对于RGB三通道颜色，每个 $\vec{c}_{lm}$ 都是一个三维向量。特别地，零阶 ($l=0$) 的基函数 $Y_{00}$ 是一个常数，因此它对应的系数 $\vec{c}_{00}$ 所代表的是该基元的漫反射颜色，即不随视角变化的基底色（也称为DC项）。所有更高阶 ($l>0$) 的项则共同叠加构成了视角相关的颜色变化部分（AC项），从而实现了对高光等复杂光照现象的模拟。通过采用球谐函数，每个高斯基元都从一个静态着色的“粒子云”，升级为了一个能够响应观察方向的微型“光照模型”，这极大地提升了最终渲染图像的真实感和物理可信度。


# 投影变换：从三维椭球到二维高斯斑点

渲染过程的起始，是将场景中所有三维高斯基元的数学描述，根据给定的相机位姿和内参，转换为其在二维图像平面上的对应表示。这个过程需要分别对基元的位置（均值）和形态（协方差）进行变换。

首先，对于第 $i$ 个基元的中心点 $\vec{\mu}_i$，其投影过程遵循标准的三维图形学变换管线。通过乘以视图矩阵 $W$（相机外参），其世界坐标被转换到相机坐标系下的坐标 $\vec{p}_{cam} = W\vec{\mu}_i$。随后，通过应用相机内参 $K$ 所定义的透视投影变换，这个三维相机空间点被最终映射到二维图像平面上的像素坐标 $\vec{\mu}'_{2D}$。

更为关键且非平凡的一步，是对描述基元形态的三维协方差矩阵 $\Sigma$ 进行变换。一个核心的数学性质是，一个多维高斯分布经过仿射变换后，其结果仍然是一个高斯分布。尽管完整的透视投影是非线性的，但对于一个远离相机中心且尺寸相对较小的三维高斯椭球，我们可以使用其中心点处的线性化，即通过该点变换的雅可比矩阵 $J$，来近似整个椭球的变换。这个雅可比矩阵捕捉了透视变换在局部所造成的拉伸和变形。给定一个在相机坐标系下表示的协方差矩阵 $\Sigma_{cam}$，它在二维图像平面上所对应的协方差矩阵 $\Sigma'_{2D}$ 可以通过以下关系式精确计算得出：

$$
\begin{equation}
\Sigma'_{2D} = J \Sigma_{cam} J^T
\end{equation}
$$

这个变换在几何上是极为直观的：它将一个三维空间中的椭球体，根据透视法则，“压平”并扭曲成图像平面上的一个二维椭圆。通过这个数学变换，我们成功地将每个三维高斯基元转换为了一个二维图像平面上的高斯“斑点”。这个二维斑点由其在图像上的中心点 $\vec{\mu}'_{2D}$ 和一个描述其椭圆形状、大小及朝向的 $2 \times 2$ 协方差矩阵 $\Sigma'_{2D}$ 所完整定义。



# 光栅化与Alpha混合的最终像素颜色合成

我们通过投影变换，为场景中的每一个三维高斯基元都计算出了其在二维图像平面上的对应表示：一个由二维均值 $\vec{\mu}'_{2D}$ 和二维协方差矩阵 $\Sigma'_{2D}$ 定义的高斯“斑点”。

现在的任务是将这些连续的二维高斯分布对离散的像素网格所产生的贡献进行计算和累积，这个过程在图形学中统称为**光栅化 (Rasterization)** 与**合成 (Composition)**。首先，由于一个高斯函数的数学定义域是无限的，我们必须确定其有效影响范围以进行高效计算。通常，我们会忽略距其中心超过若干倍标准差（例如3倍）的区域，从而为每个二维高斯斑点确定一个有限的像素包围盒。光栅化阶段的核心任务，便是对于每一个受该包围盒覆盖的像素，精确计算该高斯斑点对其的颜色与不透明度贡献。

由于高斯基元是半透明的，一个像素的最终颜色往往由多个前后重叠的高斯斑点共同决定。因此，我们必须采用一种能够正确处理遮挡与透明度的合成方法，即这里采用的方法是**Alpha混合**，它本质上是一种离散化的体渲染积分。

该过程的第一步，是将在光栅化阶段确定对同一像素有贡献的所有高斯斑点，根据它们在相机空间中的深度值进行从近到远的排序。随后，该像素的最终颜色 $C$ 通过沿视线方向，从最前方的第一个斑点开始，逐层向后累积颜色与不透明度的方式计算得出。其离散化的渲染方程为：
$$
\begin{equation}
C = \sum_{i=1}^{N} c_i \alpha'_i \prod_{j=1}^{i-1} (1 - \alpha'_j)
\end{equation}
$$

此处的**求和**是针对所有覆盖该像素并已按深度排序的 $N$ 个斑点。我们对该方程的各个组成部分进行严格定义：$c_i$ 是第 $i$ 个斑点的颜色，该颜色是根据当前视线方向由其球谐函数系数实时计算得出的。$\alpha'_i$ 是第 $i$ 个斑点对该像素中心的**有效不透明度**。它并非仅仅是基元固有的不透明度 $\alpha_i$，而是 $\alpha_i$ 与该斑点的二维高斯分布函数在当前像素中心位置的取值的乘积。这一步至关重要，它使得位于斑点中心的像素接收到更强的不透明度贡献，而边缘像素的贡献则相应减弱。最后，连乘项 $\prod_{j=1}^{i-1} (1 - \alpha'_j)$ 代表了**透射率**，即光线在到达第 $i$ 个斑点之前，成功穿透其前方所有 $i-1$ 个斑点而未被吸收的能量比例。

我们已构建了从三维高斯基元的参数化表示，到最终二维图像像素颜色的完整渲染管线。该管线中的每一步——从参数化构造、投影变换，到最终的Alpha混合——均是可微分的。正是这种端到端的可微分特性，使得我们能够计算出渲染图像与真实目标图像之间的损失函数，并将梯度反向传播回最初的三维高斯基元参数集 $\{\vec{\mu}_i, \vec{q}_i, \vec{s}_i, c_i, \alpha_i\}$。这使得利用梯度下降等优化算法，从一组二维图像中自动学习和重构出整个复杂的三维场景成为可能，这也是3D Gaussian Splatting方法的核心所在。



# 优化框架与损失函数

基于前面我们所讨论的，是一个静态的、从一组给定的高斯参数渲染出图像的“正向过程”。而场景重建的本质，则是一个“逆向过程”：给定一系列二维图像，反向推算出能够最佳重现这些图像的三维高斯参数集。这一逆向过程，在3GS中是通过基于梯度的优化来实现的。其基本输入是：一组静态场景的多视角照片，以及通过运动恢复结构 (Structure-from-Motion, SfM) 算法（如COLMAP）预先计算出的每张照片精确的相机内外参数（即位置、朝向和焦距等）。

优化的起点并非一个随机或空无一物的场景，而是利用SfM算法在计算相机位姿时附带生成的稀疏三维点云。每一个稀疏点被用作初始化一个三维高斯基元的中心位置 $\vec{\mu}$。这些初始的高斯基元在几何上被设定为各向同性的球体（即其初始缩放向量 $\vec{s}$ 各分量相等，旋转四元数 $\vec{q}$ 为单位四元数），其颜色则由该三维点在输入图像中对应的像素颜色平均值来初始化，不透明度 $\alpha$ 则被设为一个较高的初始值。

优化的核心目标，是迭代地调整这数百万个高斯基元的所有参数 $\{\vec{\mu}_i, \vec{q}_i, \vec{s}_i, c_i, \alpha_i\}$，使得在任意一个给定的相机视角下，通过我们在前几节描述的可微分渲染管线所生成的图像 $C_{rendered}$，与该视角对应的真实照片 $C_{gt}$ 之间的差异最小化。这种“差异”是通过一个数学上定义的损失函数 $\mathcal{L}$ 来量化的。优化算法的全部工作，就是求得 $\mathcal{L}$ 关于所有高斯参数的梯度，并沿着梯度下降的方向更新参数，以使 $\mathcal{L}$ 的值最小。

但是这里要是仅仅使用简单的像素级L2范数（均方误差）作为损失函数，往往会导致渲染结果过于模糊，缺乏细节。为了生成感官上更真实、更清晰的图像，3GS采用了一个混合损失函数，它由两部分加权组成：

$$
\begin{equation}
\mathcal{L} = (1 - \lambda) \mathcal{L}_{L1} + \lambda \mathcal{L}_{D-SSIM}
\end{equation}
$$

第一部分是L1损失，即渲染图像与真实图像之间逐像素颜色值的绝对差之和。它保证了整体颜色和亮度的准确性。第二部分是结构相似性 (SSIM)损失。与仅比较单个像素值的L1或L2损失不同，SSIM是一种更先进的图像质量评估指标，它同时从亮度、对比度和结构三个方面来度量两张图像的相似性，使其更符合人类的视觉感知。在损失函数中使用它，有助于优化过程更好地保持和恢复图像中的高频细节与纹理。通过最小化这个混合损失函数，优化过程被引导着去生成在数学上和感官上都与真实照片高度一致的图像。




# 自适应密度控制(上) —— 高斯基元的增殖

我们在上一节建立了优化框架，其目标是调整一组初始高斯基元的参数以最小化渲染损失。然而，这个初始集是从稀疏点云生成的，其数量和分布远不足以表征一个复杂场景的完整几何与外观。若要从稀疏走向稠密，系统必须具备在优化过程中动态增加新基元的能力。

这个问题在论文里提出了一个比较有意思的解决办法，被称为**增殖 (Densification)**，它并非盲目地添加，而是由优化过程中的梯度信息来智能引导，以确保新的基元被添加到最需要它们的地方。该增殖操作通常以固定的迭代周期（例如每100次梯度更新）被触发。

增殖的决策核心，依赖于在标准反向传播过程中计算出的**位置梯度** $\nabla_{\vec{\mu}}$。这个梯度向量的大小，直观地反映了损失函数对于某个高斯基元中心位置 $\vec{\mu}$ 的敏感程度。如果一个基元的位置梯度很大，则意味着优化算法“希望”这个基元能够大幅移动，以更好地拟合目标图像。这通常标志着该基元所在的局部三维空间存在较大的重建误差。3GS巧妙地利用这一信号，并结合基元的几何尺寸，设计了两种互补的增殖策略。

第一种策略针对 **“欠重建”(under-reconstruction)** 区域。这种情况的特征是，一个几何尺寸较小的（即覆盖范围有限的）高斯基元，却具有一个很大的位置梯度。这表明场景中存在一个需要被精细表达的几何细节，但当前仅由这一个孤立的小基元来近似，导致拟合不足。此时，系统会执行**克隆 (Clone)** 操作：它会创建一个与该基元参数完全相同的新副本，并放置在同一位置。在后续的优化迭代中，这两个并置的基元便可以自由地向不同方向移动，共同填充原先的几何“空洞”，从而提升局部的细节表现力。

第二种策略针对 **“过重建”(over-reconstruction)** 区域。其特征是，一个几何尺寸非常大的高斯基元，同样具有一个很大的位置梯度。这暗示着这个大基元可能正试图以一种粗糙的方式，去拟合一个内部包含了丰富细节或复杂几何变化的大片区域。一个大的、单一的椭球无法同时满足这片区域内各处精细的拟合要求，从而产生了较大的位置梯度。在这种情况下，系统会执行**分裂 (Split)** 操作：它会将这个大的基元分裂成两个尺寸较小的新基元。这两个新基元的参数继承自父基元，但它们的缩放尺度会被按比例缩小，并且它们的中心位置会被沿着父基元最长的主轴方向，向相反方向移动一小段距离。通过这一操作，一个粗糙的表示被两个更精细的表示所取代，为优化算法提供了更大的自由度去拟合该区域的内部细节。

通过这两种由梯度信息驱动的增殖策略，3G​​S的场景表示能够在训练过程中“生长”，从一个稀疏的点云初始化，动态地、有针对性地增加几何复杂度。




# 自适应密度控制(下) —— 高斯基元的修剪

但是我们知道，一个只增不减的系统是不可持续的，它会导致基元数量的爆炸式增长，其中包含了大量冗余、重叠或对最终渲染结果几乎没有贡献的基元。这不仅会极大地增加计算和存储开销，还可能对优化过程产生负面影响。因此，为了维持一个高效且紧凑的场景表示，增殖过程必须与一个严格的**修剪 (Pruning)** 机制相平衡。修剪操作同样以固定的迭代周期被触发，其目标是识别并移除那些对场景贡献微不足道的“无效”高斯。

修剪的决策依据主要基于两个核心指标。第一个指标是基元的**不透明度 $\alpha$**。一个极低的不透明度值，例如低于某个预设的阈值 $\epsilon_{\alpha}$，意味着该高斯基元几乎是完全透明的。这样的基元，无论其颜色和形状如何，在Alpha混合的渲染方程中，其对最终像素颜色的贡献权重 $\alpha'_i$ 都会趋近于零。因此，它在物理上对场景的遮挡和颜色贡献可以忽略不计。系统会定期检查所有高斯基元的不透明度值，并直接移除那些 $\alpha$ 值过低的基元。这个机制在训练初期尤为重要，能够快速清除掉那些被初始化在空无一物的三维空间区域（例如天空或物体内部）的稀疏点所对应的无效高斯。

第二个修剪指标则更为微妙，它关乎基元在三维空间中的**几何尺寸**。在增殖过程中，特别是分裂操作，可能会产生一些尺寸过大或过小的高斯。一个在相机视锥内尺寸过大的高斯，其投影到二维图像上可能会覆盖极大的像素区域，这往往是一种低效的场景表示，并且在优化过程中容易产生视觉瑕疵。相反，一个尺寸过小（几乎是一个点）的高斯，它可能对最终图像的贡献局限在单个像素之内甚至更小，这对于构建一个连续的表面来说是冗余的。因此，系统会设定尺寸的上下限阈值，并定期修剪那些变得过大或过小的基元。

通过结合不透明度和尺寸这两个维度的判断，修剪机制能够有效地控制高斯基元总数的增长，剔除对场景表达无益的冗余部分，确保计算资源被集中用于优化那些对最终渲染质量有显著贡献的关键基元。增殖与修剪这一对相辅相成的动态过程，共同构成了3GS强大的自适应密度控制系统。它使得场景表示能够从一个粗糙的初始状态，通过自我调节，自动地调整其局部密度和复杂度，最终“生长”成一个既精确又高效的、能够完美重现真实世界细节的稠密表示。至此，已经完整地解析了3GS的优化核心。




# 场景表示的根本分歧 —— 显式与隐式

NeRF (Neural Radiance Fields) 的核心思想是采用一种**隐式 (Implicit)** 的、基于坐标的神经表示方法。具体来说，它使用一个深度神经网络（通常是一个多层感知机，MLP）来近似一个连续的五维函数 $F: (\vec{x}, \vec{d}) \rightarrow (c, \sigma)$。这个函数以一个三维空间坐标点 $\vec{x}=(x,y,z)$ 和一个二维观察方向 $\vec{d}=(\theta, \phi)$ 作为输入，输出该点在该观察方向下的颜色值 $c=(r,g,b)$ 和体密度 $\sigma$。在这个框架中，整个三维场景的几何形状和外观信息，并非以任何直接的、可读的数据结构（如网格或点云）存在，而是被完全编码、“压缩”在了这个神经网络的数百万个权重和偏置参数之中。场景本身就是这个网络。若想查询空间中任意一点的属性，唯一的办法就是向这个网络输入该点的坐标并执行一次前向传播计算。这是一种连续、平滑且内存占用极小的场景表示方式，但其代价是查询效率极低。

与此形成鲜明对比的是，3D Gaussian Splatting 采用了一种完全**显式 (Explicit)** 的、基于基元的表示方法。正如我们前几段学习的，3GS将一个场景描述为数百万个独立的三维高斯基元的集合。整个场景的数据被直接、明文地存储在一个巨大的列表中，列表的每一项都包含了描述一个高斯基元所需的全部参数（位置、旋转、缩放、球谐函数系数、不透明度）。场景的几何与外观信息是具象化的、离散化的，并且存储在易于访问的显存之中。我们可以直接读取、修改甚至删除任意一个高斯基元，而无需进行任何复杂的网络查询。这种表示方式牺牲了NeRF的极度压缩性，换来的是查询和操作数据时的极高效率。

故NeRF与3GS在场景表示上的核心分歧在于：NeRF是一种**连续、隐式、基于坐标查询的神经函数表示**，而3GS是一种**离散、显式、基于几何基元的结构化数据表示**。这个在表示方法上的根本分歧，是两者后续所有差异的根源，并直接导致了它们在**渲染机制和执行速度**上存在着天壤之别。



# 渲染机制的对比 —— 光线步进与光栅化

我们确立了NeRF与3GS在场景表示方法上的根本分歧这一核心差异，直接决定了它们必须采用两种截然不同的渲染算法来生成图像，并由此产生了两者在性能上的巨大鸿沟。

NeRF的渲染过程严格遵循了物理光学中的体渲染 (Volume Rendering) 原理，其核心算法是**光线步进 (Ray Marching)**。为了计算单个像素的颜色，系统会从相机中心发射一条穿过该像素的光线。由于场景是一个由神经网络定义的连续辐射场，无法进行解析积分，因此算法必须沿着这条光线进行离散采样，在其路径上生成数百个采样点。对于每一个采样点，都必须执行一次对神经网络（MLP）的查询，输入该点的三维坐标和光线方向，以获取该点的颜色和体密度。在收集到光线上所有采样点的属性后，系统会依据体渲染方程，将这些离散的颜色和密度值从后向前或从前向后积分（混合），最终计算出该条光线所累积的颜色，即像素的最终颜色。这个过程在逻辑上非常清晰且物理意义明确，但其计算代价极为高昂：渲染一张百万像素的图像，需要执行数亿次对大型神经网络的查询，这使得NeRF的渲染速度非常缓慢，远无法达到实时。

与此相反，3D Gaussian Splatting的渲染过程摒弃了光线步进，转而采用了一种更接近于传统计算机图形学的、基于**光栅化** 的方法。它并非将视线“探入”场景，而是将场景中的所有基元“拍扁”到屏幕上。整个过程分为两步：首先，场景中数以百万计的三维高斯基元，通过我们在第五节中描述的投影变换，被一次性地、并行地全部投影到二维图像平面上，形成对应的二维高斯“斑点”。这个投影操作在数学上是确定性的，并且可以被现代GPU的并行计算架构极大地加速。其次，在所有二维斑点生成后，系统对它们进行一次全局的、基于深度的快速排序。最后，GPU的光栅化硬件高效地遍历每个像素，并根据排序结果，将所有覆盖该像素的斑点颜色，按照我们在第六节中描述的Alpha混合公式，从前向后依次混合，从而合成最终的像素颜色。

因此，两种技术的渲染机制存在本质区别：NeRF采用的是一种 **“查询式”**的、逐像素独立积分的**光线追踪**方法，其性能瓶頸在于神经网络的查询次数和深度；而3GS采用的是一种 **“投影式”**的、对所有基元并行处理的**光栅化**方法，其性能优势在于充分利用了GPU为渲染几何图元而专门设计的硬件能力。正是这种从根本算法上的不同，使得3GS能够将原本需要数秒甚至数分钟才能渲染一帧的神经场景，提升到可以实时交互的水平。渲染机制的巨大差异，也直接决定了两者在训练效率上的不同表现。




# 训练效率对比的反向传播路径差异

我们在前面已经明确，3D Gaussian Splatting (3GS) 的渲染速度远超NeRF，这一优势同样也延伸到了训练阶段，并且其背后的原因与渲染机制的差异密切相关。一个典型的NeRF模型通常需要数小时甚至数天才能完成训练，而3GS则能将同样场景的训练时间缩短到数分钟，这种数量级的提升源于两者在优化过程中梯度计算与反向传播路径的根本不同。

在NeRF的训练流程中，其可优化的参数是构成隐式神经表示的神经网络（MLP）的全部权重。当计算损失函数关于这些权重的梯度时，反向传播的路径非常长且计算密集。梯度信号从渲染图像的像素颜色出发，首先需要穿过体渲染的数值积分公式，然后回传到光线上成百上千个采样点，最后，对于每一个采样点，梯度还必须进一步穿过整个深度神经网络的所有层，直至抵达网络的权重参数。通过一个大型MLP进行反向传播是整个训练过程的性能瓶颈。本质上，NeRF是通过调整一个庞大而复杂的函数（神经网络）的参数，来间接地、缓慢地改变三维场景的几何与外观，其优化过程缺乏直接的几何控制。

相比之下，3GS的训练过程则高效得多。其优化的对象是数百万个高斯基元的显式参数（位置、旋转、缩放、颜色系数、不透明度）。其反向传播的路径大大缩短，且更为直接。梯度信号从像素颜色出发，只需穿过我们在第六节讨论的、结构相对简单的Alpha混合公式，然后就可以直接计算出对该像素有贡献的少数几个高斯基元的二维“斑点”参数的梯度。随后，通过投影变换的雅可比矩阵的逆向应用，这些二维梯度被直接映射回每个对应三维高斯基元的显式参数上。整个流程中，**不存在任何需要穿透的深度神经网络**。梯度直接作用于场景的几何和外观描述符，使得每次参数更新都具有明确的物理和几何意义，从而实现了极高的收敛速度。

所以NeRF的训练效率受限于其“查询-积分-反向传播过MLP”的循环，每一步都涉及大量的神经网络运算。而3GS则将此过程转变为一个“投影-光栅化-反向传播至显式参数”的高效管线，这个管线可以被专门为此设计的、高度优化的可微分光栅化器在GPU上以极高的效率执行。正是这种从隐式神经函数到显式几何基元的范式转移，构成了3GS在训练速度上取得革命性突破的根本原因。